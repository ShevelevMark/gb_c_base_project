#include <read.h>
#include <ctype.h>

/**
 * ДЛЯ ПРОВЕРЯЮЩЕГО
 * Насколько я понял из общения с преподавателем Дарьей Шмелёвой и из примеров
 * правильные входящие данные должны иметь такой вид: ^\d{4}(;[ \d]\d){4};( \d|\d\d|-\d|-\d\d)$
 * По здравому разумению следовало бы использовать решения с проверной на соответсвие строки регулярному 
 * множеству, но в стандартной библиотеки C я таких возможностей не нашёл, потому написал свою 
 * простую проверку для конкретного шаблона.
 */

/**
 * Проверка на соответствие завершаемой нулём строки шаблону входных данных:
 * ^\d{4}(;[ \d]\d){4};( \d|-\d\d|-\d)$
 * Конец строки - завершающий ноль
 * @param char const * str указатель на верную память, возможно пустую строку, но с завершающим нулём
 * @return bool true, если строка соответсвует шаблону, иначе - false
 */
bool validate_string(char const *str) {
    /* Проверка на первые четыре цифры года \d{4}*/
    for (unsigned cnt = 0; cnt != 4; ++cnt, ++str) if (!isdigit(str[0])) return false;
    
    /* Проверка на цетыре элемента вида ;[ \d]\d */
    for (unsigned cnt = 0; cnt != 4; ++cnt, str += 3)
        if (';' != str[0] || ( !(' ' == str[1] && isdigit(str[2])) && !(isdigit(str[1]) && isdigit(str[2])) ) ) return false;

    /* Проверка на завершающую комбинацию ;( \d|\d\d|-\d\d|-\d)$ */
    if (';' != *str) return false;
    ++str;

    if ((' ' == str[0] || isdigit(str[0])) && isdigit(str[1]) && 0 == str[2]) return true; // \d|\d\d$
    if ('-' == str[0] && isdigit(str[1]) && 0 == str[2] ) return true;                     // -\d$
    if ('-' == str[0] && isdigit(str[1]) && isdigit(str[2]) && 0 == str[3]) return true;   // -\d\d$

    return false;
} 