#include <read.h>
#include <ctype.h>

/**
 * ДЛЯ ПРОВЕРЯЮЩЕГО
 * Насколько я понял из общения с преподавателем Дарьей Шмелёвой и из примеров
 * правильные входящие данные должны иметь такой вид: ^\d{4}(;[ \d]\d){4};( \d|\d\d|-\d|-\d\d)$
 * По здравому разумению следовало бы использовать решения с проверкой на соответсвие строки регулярному 
 * множеству, но в стандартной библиотеке C я таких возможностей не нашёл, потому написал свою 
 * простую проверку для конкретного шаблона.
 */

/**
 * Проверка на соответствие завершаемой нулём строки шаблону входных данных:
 * ^\d{4}(;[ \d]\d){4};( \d|-\d\d|-\d)$
 * Конец строки - завершающий ноль
 * 
 * @param char const * str - указатель на верную память, возможно пустую строку, но с завершающим нулём
 * 
 * @return bool - true, если строка соответсвует шаблону, иначе - false
 */
bool validate_string(char const *str) {
    /* Проверка на первые четыре цифры года \d{4}*/
    for (unsigned cnt = 0; cnt != 4; ++cnt, ++str) if (!isdigit(str[0])) return false;
    
    /* Проверка на цетыре элемента вида ;[ \d]\d */
    for (unsigned cnt = 0; cnt != 4; ++cnt, str += 3)
        if (';' != str[0] || ( !(' ' == str[1] && isdigit(str[2])) && !(isdigit(str[1]) && isdigit(str[2])) ) ) return false;

    /* Проверка на завершающую комбинацию ;( \d|\d\d|-\d\d|-\d)$ */
    if (';' != *str) return false;
    ++str;

    if ((' ' == str[0] || isdigit(str[0])) && isdigit(str[1]) && 0 == str[2]) return true; // \d|\d\d$
    if ('-' == str[0] && isdigit(str[1]) && 0 == str[2] ) return true;                     // -\d$
    if ('-' == str[0] && isdigit(str[1]) && isdigit(str[2]) && 0 == str[3]) return true;   // -\d\d$

    return false;
} 

/**
 * Проверка входящих данных на соответствие верным значениям
 * года, месяца, дня, часов, минут и температуры. Принимаемаея строка 
 * должна соответствовать шаблону ^\d{4}(;[ \d]\d){4};( \d|-\d\d|-\d)$.
 * 
 * @param char const * str - указательна на начало строки, содержаещей необходимые данные.
 * @param int * year        - год в пределах от 1900 до 3000
 * @param int * month       - номер месяца от 1 до 12
 * @param int * day         - номер дня в пределах от 1 до 31
 * @param int * hour        - номер часа от 0 до 23
 * @param int * minute      - номер минуты от 0 до 59
 * @param int * temperature - зафиксированная температура от -99 до 99
 * 
 * @return bool - true, если данные удалось успешно прочитать и они лежат в нужных пределах, иначе - false;
 *                не следует читать данные по переданным адресам, если функция не вернула true, возможно данные 
 *                не были записаны.
 */
bool validate_data(char const *str, int *year, int *month, int *day, int *hour, int *minute, int *temperature) {
    if (6 != sscanf(str, "%d;%d;%d;%d;%d;%d", year, month, day, hour, minute, temperature)) return false;
    if (1900 > *year || 3000 < *year ) return false;
    if (1 > *month || 12 < *month) return false;
    if (1 > *day || 31 < *day) return false;
    if (0 > *hour || 23 < *hour) return false;
    if (0 > *minute || 59 < *minute) return false;
    if (-99 > *temperature || 99 < *temperature) return false;
    return true;
}

/**
 * Функция считывает из потока по переданному дескриптору строку данных в буфер.
 * Считывается не более 21 символа до первого символа перевода строки '\n', 
 * что наступит раньше. Передаваемый буфер должен содержать достаточно памяти 
 * для 22 элементов типа char (21 символ из файла + 1 на завершающий ноль).
 * После считывания 21 символа функция пропустит все данные до символаа перевода
 * строки, а затем и сам символ перевода строки '\n'.
 * 
 * @param FILE * fd     - указатель-десткриптор потока ввода
 * @param char * buffer - буфер, в который происходит запись считанных символов
 * 
 * @return bool - если считать данные не удалось (не считалось ни одного символа), 
 *                функция вернёт false, иначе - true  
 */
bool read_line(FILE *fd, char *buffer) {
    if (1 != fscanf(fd, "%21[^\n]s", buffer)) return false;
    fscanf(fd, "%*[^\n]s");
    fscanf(fd, "%*c");
    return true;
}